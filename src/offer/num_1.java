package offer;

/**
 * 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
 * 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。
 * 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
 * NOTE：给出的所有元素都大于0，若数组大小为0，。
 * <p>
 * 解题思路：
 * <p>
 * 本题的直观解法很简单，直接对数组进行一次遍历就可以找到最小值，复杂度为O(n)，但是显然这不是本题的意图所在，因为没有利用到任何旋转数组的特性。
 * <p>
 * 进一步分析，如果整个数组是有序的，那我们一定会想到用折半查找来实现。
 * <p>
 * 对于旋转数组，我们发现，它实际上可以划分为两个排序的子数组，而且前面数组的元素都不小于后面数组的元素，并且最小值正好就是这两个数组的分界线，
 * <p>
 * 由此，我们可以得出以下解决方法。
 * <p>
 * 首先用两个指针low和high分别指向数组的第一个元素和最后一个元素，然后可以找到中间元素mid。
 * <p>
 * 对于这个中间元素，有以下两种情况：
 * <p>
 * （1）该元素大于等于low指向的元素，此时最小的元素说明在mid的后面，可以把low=mid；
 * <p>
 * （2）中间元素小于等于high指向的元素请返回0，那么最小元素在mid之前，可以high=mid。
 * <p>
 * 特别注意：这里不要+1或者-1，因为只有这样才能保证low始终在第一个数组，high始终在第二个数组。
 * <p>
 * 依次循环，当最后low和high相差1时，low指向第一个数组的最后一个，high指向第二个数组的第一个（即为我们要找的最小值）。
 * <p>
 * 很明显，以上查找的时间复杂度为O(logN)。
 */
public class num_1 {
    public static void main(String[] args) {
        int[] arr = {3, 4, 5, 1, 2};
        System.out.println(minNum(arr));
    }

    public static int minNum(int[] arr) {
        if (arr.length == 0) {
            return 0;
        }
        int len = arr.length - 1;
        if (arr[0] < arr[len]) {
            return arr[0];
        }
        //6,7,8,1,2,3,4,5
        int low = 0, h = len;
        while (low <= h) {
            int mid = (low + h) / 2;
            /**
             * 说明mid在左半部分
             */
            if (arr[mid] > arr[h]) {
                low = mid + 1;
            } else if (arr[mid] < arr[h]) {
                //mid 在右半部分
                h = mid;
            } else {
                //旋转点在两个数字之间
                h--;
            }
        }
        return arr[low];
    }


}
